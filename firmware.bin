#include <TinyGPSPlus.h>
#include <HardwareSerial.h>
#include <XPowersLib.h>
#include <WiFi.h>
#include <WiFiClientSecure.h>
#include <HTTPClient.h>
#include <time.h>


// ------------------ TELEGRAM CONFIG -------------------
const char* ssid = "MEO-7C6930";
const char* password = "0d2ad4596f";
const char* BOT_TOKEN = "7090059734:AAECfFez6-5pJVqOviJyZhXtmvfn9NMDfBE";
const char* CHAT_ID = "220442872";
// ------------------------------------------------------


unsigned long lastSendTime = 0;
const unsigned long sendInterval = 15000; // 15 —Å–µ–∫—É–Ω–¥


// GPS Serial Pins
#define GPS_RX_PIN 34
#define GPS_TX_PIN 12

// I2C for AXP2101
#define I2C_SDA_PIN 21
#define I2C_SCL_PIN 22

TinyGPSPlus gps;
HardwareSerial GPS_Serial(1);
XPowersAXP2101 power;

#define GPS_BAUD_RATE 9600

void setup() {
  Serial.begin(115200);
  while (!Serial);
  Serial.println("GPS T-Beam + Telegram");

  // WiFi Init
  Serial.print("Connecting to WiFi...");
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("\nWiFi connected. IP: " + WiFi.localIP().toString());

  // --- Check Telegram DNS ---
  IPAddress tg_ip;
  if (WiFi.hostByName("api.telegram.org", tg_ip)) {
    Serial.print("üîó Telegram API IP: ");
    Serial.println(tg_ip);
  } else {
    Serial.println("‚ùå DNS lookup for Telegram failed!");
  }
  Serial.println(WiFi.dnsIP());

  Wire.begin(I2C_SDA_PIN, I2C_SCL_PIN);
  if (!power.init()) {
    Serial.println("PMIC FAIL");
    while (1) delay(1000);
  }
  power.setProtectedChannel(XPOWERS_ALDO2);
  power.enableALDO2(); // –í–∫–ª—é—á–∏—Ç—å GPS

  GPS_Serial.begin(GPS_BAUD_RATE, SERIAL_8N1, GPS_RX_PIN, GPS_TX_PIN);
  fakeTime();

}


void fakeTime() {
  // –ü—Ä–∏–º–µ—Ä: 24 –º–∞—è 2025 03:00:00 UTC
  struct tm t;
  t.tm_year = 2025 - 1900;
  t.tm_mon = 5;     // –ú–∞–π = 5 (—è–Ω–≤ = 0)
  t.tm_mday = 24;
  t.tm_hour = 3;
  t.tm_min = 0;
  t.tm_sec = 0;
  time_t fakeEpoch = mktime(&t);
  struct timeval now = { .tv_sec = fakeEpoch };
  settimeofday(&now, nullptr);

  Serial.println("‚ö†Ô∏è –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø–æ–¥—Å—Ç–∞–≤–Ω–æ–µ –≤—Ä–µ–º—è (–±–µ–∑ NTP)");
  Serial.print("üïí ");
  Serial.println(ctime(&fakeEpoch));
}


void syncTime() {
  configTime(0, 0, "time.google.com", "time.nist.gov", "pool.ntp.org");
  setenv("TZ", "UTC0", 1);  // –∏–ª–∏ –Ω—É–∂–Ω—ã–π —Ç–µ–±–µ —á–∞—Å–æ–≤–æ–π –ø–æ—è—Å
  tzset();

  Serial.println("‚è≥ Waiting for NTP time sync...");

  int waitSec = 0;
  time_t now = time(nullptr);
  while (now < 100000 && waitSec < 10) {
    delay(500);
    Serial.print(".");
    waitSec++;
    now = time(nullptr);
  }

  Serial.println();
  if (now >= 100000) {
    Serial.println("‚úÖ Time synced.");
    Serial.print("üïí ");
    Serial.println(ctime(&now));
  } else {
    Serial.println("‚ùå Time sync FAILED. Using default time.");
  }
}


void loop() {
  while (GPS_Serial.available() > 0) {
    char c = GPS_Serial.read();
    Serial.write(c); // –ø–æ–∫–∞–∂–µ—Ç "—Å—ã—Ä—ã–µ" NMEA –¥–∞–Ω–Ω—ã–µ, –µ—Å–ª–∏ –ø—Ä–∏—Ö–æ–¥—è—Ç
    if (gps.encode(c) && gps.location.isValid()) {
    if (millis() - lastSendTime > sendInterval) {
    displayAndSendInfo();
    lastSendTime = millis();
    if (millis() % 5000 < 50) {
    Serial.print("üì° –°–ø—É—Ç–Ω–∏–∫–∏: ");
    Serial.println(gps.satellites.value());
    Serial.print("üì∂ HDOP: ");
    Serial.println(gps.hdop.value() / 100.0);
}

  }
}
  }

  if (millis() > 5000 && gps.charsProcessed() < 10) {
    Serial.println("WARNING: No GPS data!");
    ESP.restart();  // –µ—Å–ª–∏ GPS –∑–∞–≤–∏—Å
  }
}

void displayAndSendInfo() {
  Serial.print("Fix: ");
  if (gps.location.isValid()) {

    static double lastLat = 0, lastLng = 0;
    static unsigned long lastSent = 0;
    static bool wasMoving = false;

    double lat = gps.location.lat();
    double lng = gps.location.lng();
    double dist = abs(lat - lastLat) + abs(lng - lastLng); // –≥—Ä—É–±–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ
    unsigned long now = millis();

    bool isMoving = dist > 0.00008; // –ø—Ä–∏–º–µ—Ä–Ω–æ 5 –º–µ—Ç—Ä–æ–≤

    if (!isMoving && (now - lastSent < 60000)) {
      Serial.println("üßç –°—Ç–∞—Ü–∏–æ–Ω–∞—Ä–Ω–æ. –ú–µ–Ω–µ–µ 1 –º–∏–Ω—É—Ç—ã. –ù–µ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º.");
      return;
    }
    if (isMoving && (now - lastSent < 15000)) {
      Serial.println("üèÉ –î–≤–∏–∂–µ–Ω–∏–µ. –ú–µ–Ω–µ–µ 15 —Å–µ–∫—É–Ω–¥. –ù–µ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º.");
      return;
    }

    lastLat = lat;
    lastLng = lng;
    lastSent = now;
    wasMoving = isMoving;

    // üëá —Ç–≤–æ–π —Ç–µ–∫—É—â–∏–π –∫–æ–¥ —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏—è:
    int sats = gps.satellites.value();
    double hdop = gps.hdop.value() / 100.0;
    double alt = gps.altitude.meters();

    Serial.printf("VALID | Lat: %.6f | Lng: %.6f | Sats: %d | HDOP: %.1f | Alt: %.1fm\n",
                  lat, lng, sats, hdop, alt);

    String msg = "üìç –ù–æ–≤–∞—è GPS –ø–æ–∑–∏—Ü–∏—è:\n";
    msg += "üåê Lat: " + String(lat, 6) + "\n";
    msg += "üåê Lng: " + String(lng, 6) + "\n";
    msg += "üì° Sats: " + String(sats) + "\n";
    msg += "üìè HDOP: " + String(hdop, 1) + "\n";
    msg += "üóª Alt: " + String(alt, 1) + " m\n";
    msg += "üó∫Ô∏è https://maps.google.com/?q=" + String(lat, 6) + "," + String(lng, 6) + "\n";

    sendToTelegram(msg);
  } else {
    Serial.println("INVALID | Lat: --- | Lng: ---");
  }
}



bool sendToTelegram(const String& message) {
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("üö´ WiFi not connected. Cannot send Telegram.");
    return false;
  }

  WiFiClientSecure client;
  client.setInsecure(); // Skip cert verification (simpler for embedded)

  HTTPClient https;
  String url = "https://api.telegram.org/bot" + String(BOT_TOKEN) + "/sendMessage";
  String payload = "chat_id=" + String(CHAT_ID) + "&text=" + urlencode(message);

  const int maxRetries = 3;
  int attempt = 0;
  bool success = false;

  while (attempt < maxRetries && !success) {
    Serial.printf("üì§ Attempt %d to send Telegram message...\n", attempt + 1);
    if (!https.begin(client, url)) {
      Serial.println("‚ùå HTTPS begin() failed.");
      break;
    }

    https.addHeader("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8");
    int httpCode = https.POST(payload);

    if (httpCode > 0) {
      Serial.printf("‚úÖ Telegram response code: %d\n", httpCode);
      success = (httpCode == 200);
    } else {
      Serial.printf("‚ö†Ô∏è HTTP POST failed. Code: %d | Error: %s\n", httpCode, https.errorToString(httpCode).c_str());
    }

    https.end();
    attempt++;
    if (!success) delay(1500); // Wait before retry
  }

  if (!success) {
    Serial.println("‚ùå All attempts to send Telegram failed.");
  }

  return success;
}



String urlencode(String str) {
  String encoded = "";
  char c;
  char code0, code1;
  for (int i = 0; i < str.length(); i++) {
    c = str.charAt(i);
    if (isalnum(c)) {
      encoded += c;
    } else {
      code1 = (c & 0xf) + '0';
      if ((c & 0xf) > 9) code1 = (c & 0xf) - 10 + 'A';
      code0 = ((c >> 4) & 0xf) + '0';
      if (((c >> 4) & 0xf) > 9) code0 = ((c >> 4) & 0xf) - 10 + 'A';
      encoded += '%';
      encoded += code0;
      encoded += code1;
    }
  }
  return encoded;
}
