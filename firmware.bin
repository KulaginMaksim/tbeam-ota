#include <TinyGPSPlus.h>
#include <HardwareSerial.h>
#include <XPowersLib.h>
#include <WiFi.h>
#include <WiFiClientSecure.h>
#include <HTTPClient.h>
#include <time.h>
#include <algorithm>


// ------------------ TELEGRAM CONFIG -------------------
const char* ssid = "MEO-7C6930";
const char* password = "0d2ad4596f";
const char* BOT_TOKEN = "7090059734:AAECfFez6-5pJVqOviJyZhXtmvfn9NMDfBE";
const char* CHAT_ID = "220442872";
// ------------------------------------------------------


unsigned long lastSendTime = 0;
const unsigned long sendInterval = 15000; // 15 —Å–µ–∫—É–Ω–¥


// GPS Serial Pins
#define GPS_RX_PIN 34
#define GPS_TX_PIN 12

// I2C for AXP2101
#define I2C_SDA_PIN 21
#define I2C_SCL_PIN 22

TinyGPSPlus gps;
HardwareSerial GPS_Serial(1);
XPowersAXP2101 power;

#define GPS_BAUD_RATE 9600

void setup() {
  Serial.begin(115200);
  while (!Serial);
  Serial.println("GPS T-Beam + Telegram");

  // WiFi Init
  Serial.print("Connecting to WiFi...");
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("\nWiFi connected. IP: " + WiFi.localIP().toString());

  // --- Check Telegram DNS ---
  IPAddress tg_ip;
  if (WiFi.hostByName("api.telegram.org", tg_ip)) {
    Serial.print("üîó Telegram API IP: ");
    Serial.println(tg_ip);
  } else {
    Serial.println("‚ùå DNS lookup for Telegram failed!");
  }
  Serial.println(WiFi.dnsIP());

  Wire.begin(I2C_SDA_PIN, I2C_SCL_PIN);
  if (!power.init()) {
    Serial.println("PMIC FAIL");
    while (1) delay(1000);
  }
  power.setProtectedChannel(XPOWERS_ALDO2);
  power.enableALDO2(); // –í–∫–ª—é—á–∏—Ç—å GPS

  GPS_Serial.begin(GPS_BAUD_RATE, SERIAL_8N1, GPS_RX_PIN, GPS_TX_PIN);
  fakeTime();

}


void fakeTime() {
  // –ü—Ä–∏–º–µ—Ä: 24 –º–∞—è 2025 03:00:00 UTC
  struct tm t;
  t.tm_year = 2025 - 1900;
  t.tm_mon = 5;     // –ú–∞–π = 5 (—è–Ω–≤ = 0)
  t.tm_mday = 24;
  t.tm_hour = 3;
  t.tm_min = 0;
  t.tm_sec = 0;
  time_t fakeEpoch = mktime(&t);
  struct timeval now = { .tv_sec = fakeEpoch };
  settimeofday(&now, nullptr);

  Serial.println("‚ö†Ô∏è –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø–æ–¥—Å—Ç–∞–≤–Ω–æ–µ –≤—Ä–µ–º—è (–±–µ–∑ NTP)");
  Serial.print("üïí ");
  Serial.println(ctime(&fakeEpoch));
}


void syncTime() {
  configTime(0, 0, "time.google.com", "time.nist.gov", "pool.ntp.org");
  setenv("TZ", "UTC0", 1);  // –∏–ª–∏ –Ω—É–∂–Ω—ã–π —Ç–µ–±–µ —á–∞—Å–æ–≤–æ–π –ø–æ—è—Å
  tzset();

  Serial.println("‚è≥ Waiting for NTP time sync...");

  int waitSec = 0;
  time_t now = time(nullptr);
  while (now < 100000 && waitSec < 10) {
    delay(500);
    Serial.print(".");
    waitSec++;
    now = time(nullptr);
  }

  Serial.println();
  if (now >= 100000) {
    Serial.println("‚úÖ Time synced.");
    Serial.print("üïí ");
    Serial.println(ctime(&now));
  } else {
    Serial.println("‚ùå Time sync FAILED. Using default time.");
  }
}


void loop() {
  while (GPS_Serial.available() > 0) {
    char c = GPS_Serial.read();
    Serial.write(c); // –ø–æ–∫–∞–∂–µ—Ç "—Å—ã—Ä—ã–µ" NMEA –¥–∞–Ω–Ω—ã–µ, –µ—Å–ª–∏ –ø—Ä–∏—Ö–æ–¥—è—Ç
    if (gps.encode(c) && gps.location.isValid()) {
    if (millis() - lastSendTime > sendInterval) {
    displayAndSendInfo();
    lastSendTime = millis();
    if (millis() % 5000 < 50) {
    Serial.print("üì° –°–ø—É—Ç–Ω–∏–∫–∏: ");
    Serial.println(gps.satellites.value());
    Serial.print("üì∂ HDOP: ");
    Serial.println(gps.hdop.value() / 100.0);
}

  }
}
  }

  if (millis() > 5000 && gps.charsProcessed() < 10) {
    Serial.println("WARNING: No GPS data!");
    ESP.restart();  // –µ—Å–ª–∏ GPS –∑–∞–≤–∏—Å
  }
}



void displayAndSendInfo() {
  if (!gps.location.isValid()) {
    Serial.println("INVALID | Lat: --- | Lng: ---");
    return;
  }

  static double lastLat = 0, lastLng = 0;
  static unsigned long lastSent = 0;
  static bool wasMoving = false;
  static double moveBuffer[5] = {0};
  static int bufferIndex = 0;
  static bool gpsInitialized = false;

  double lat = gps.location.lat();
  double lng = gps.location.lng();

  if (!gpsInitialized) {
    lastLat = lat;
    lastLng = lng;
    gpsInitialized = true;
    Serial.println("‚è≥ –ü–µ—Ä–≤–∞—è –≤–∞–ª–∏–¥–Ω–∞—è —Ç–æ—á–∫–∞. –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç.");
    return;
  }

  double dist = distanceBetween(lastLat, lastLng, lat, lng); // –º–µ—Ç—Ä—ã
  unsigned long now = millis();

  // –ö–∞—á–µ—Å—Ç–≤–æ —Å–∏–≥–Ω–∞–ª–∞
  bool gpsGood = gps.hdop.value() / 100.0 <= 2.0 && gps.satellites.value() >= 6;

  // –û–±–Ω–æ–≤–ª—è–µ–º –±—É—Ñ–µ—Ä —Å–º–µ—â–µ–Ω–∏–π
  moveBuffer[bufferIndex] = dist;
  bufferIndex = (bufferIndex + 1) % 5;

  // –ú–µ–¥–∏–∞–Ω–Ω—ã–π —Ñ–∏–ª—å—Ç—Ä
  double tempBuffer[5];
  memcpy(tempBuffer, moveBuffer, sizeof(moveBuffer));
  std::sort(tempBuffer, tempBuffer + 5);
  double medianDist = tempBuffer[2];

  // –ü—Ä–æ–≤–µ—Ä–∫–∞: –≤—Å–µ 5 —Ç–æ—á–µ–∫ –≤—ã—à–µ 35–º
  bool allAboveThreshold = true;
  for (int i = 0; i < 5; i++) {
    if (moveBuffer[i] <= 35.0) {
      allAboveThreshold = false;
      break;
    }
  }

  // –£—Å–ª–æ–≤–∏—è –¥–≤–∏–∂–µ–Ω–∏—è
  bool isMoving = gpsGood && dist > 35.0 && medianDist > 35.0 && allAboveThreshold;

  // –ù–µ —à–ª–µ–º, –µ—Å–ª–∏ —Å—Ç–∞—Ç—É—Å –Ω–µ –ø–æ–º–µ–Ω—è–ª—Å—è –∏ –ø—Ä–æ—à–ª–æ –º–∞–ª–æ –≤—Ä–µ–º–µ–Ω–∏
  if (isMoving == wasMoving) {
    if ((isMoving && (now - lastSent < 15000)) || (!isMoving && (now - lastSent < 3600000))) {
      Serial.println(isMoving ? "üèÉ –î–≤–∏–∂–µ–º—Å—è. –ü–æ–¥–æ–∂–¥—ë–º..." : "üßç –°—Ç–∞—Ü–∏–æ–Ω–∞—Ä–Ω–æ. –ü–æ–¥–æ–∂–¥—ë–º...");
      return;
    }
  }

  // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
  lastLat = lat;
  lastLng = lng;
  lastSent = now;
  wasMoving = isMoving;

  // –ü–æ–ª—É—á–∞–µ–º —Å—Ç–∞—Ç—É—Å –±–∞—Ç–∞—Ä–µ–∏
  float battVoltage = power.getBattVoltage(); // –≤ –º–∏–ª–ª–∏–≤–æ–ª—å—Ç–∞—Ö

  // –î–∞–Ω–Ω—ã–µ
  int sats = gps.satellites.value();
  double hdop = gps.hdop.value() / 100.0;
  double alt = gps.altitude.meters();

  Serial.printf("VALID | Lat: %.6f | Lng: %.6f | Sats: %d | HDOP: %.1f | Alt: %.1fm | Dist: %.1fm | Median: %.1fm\n",
                lat, lng, sats, hdop, alt, dist, medianDist);

  // –§–æ—Ä–º–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
  String msg = isMoving
      ? "üèÉ –ú—ã –¥–≤–∏–∂–µ–º—Å—è!\nüìç GPS –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–∞–∂–¥—ã–µ 15 —Å–µ–∫—É–Ω–¥\n"
      : "üßç –°—Ç–∞—Ü–∏–æ–Ω–∞—Ä–Ω–æ.\nüìç GPS –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ä–∞–∑ –≤ —á–∞—Å\n";

  msg += "üåê Lat: " + String(lat, 6) + "\n";
  msg += "üåê Lng: " + String(lng, 6) + "\n";
  msg += "üì° Sats: " + String(sats) + "\n";
  msg += "üìè HDOP: " + String(hdop, 1) + "\n";
  msg += "üóª Alt: " + String(alt, 1) + " –º\n";
  msg += "üìè –°–º–µ—â–µ–Ω–∏–µ (–º–≥–Ω–æ–≤–µ–Ω–Ω–æ–µ): " + String(dist, 1) + " –º\n";
  msg += "üìä –ú–µ–¥–∏–∞–Ω–Ω–æ–µ —Å–º–µ—â–µ–Ω–∏–µ: " + String(medianDist, 1) + " –º\n";
  msg += "üîã –ù–∞–ø—Ä—è–∂–µ–Ω–∏–µ –±–∞—Ç–∞—Ä–µ–∏: " + String(battVoltage / 1000.0, 2) + " –í\n";
  msg += "üó∫Ô∏è https://maps.google.com/?q=" + String(lat, 6) + "," + String(lng, 6) + "\n";

  sendToTelegram(msg);
}



double distanceBetween(double lat1, double lon1, double lat2, double lon2) {
  const double R = 6371000; // –†–∞–¥–∏—É—Å –ó–µ–º–ª–∏ –≤ –º–µ—Ç—Ä–∞—Ö
  double dLat = radians(lat2 - lat1);
  double dLon = radians(lon2 - lon1);
  double a = sin(dLat / 2) * sin(dLat / 2) +
             cos(radians(lat1)) * cos(radians(lat2)) *
             sin(dLon / 2) * sin(dLon / 2);
  double c = 2 * atan2(sqrt(a), sqrt(1 - a));
  return R * c;
}

bool sendToTelegram(const String& message) {
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("üö´ WiFi not connected. Cannot send Telegram.");
    return false;
  }

  WiFiClientSecure client;
  client.setInsecure(); // Skip cert verification (simpler for embedded)

  HTTPClient https;
  String url = "https://api.telegram.org/bot" + String(BOT_TOKEN) + "/sendMessage";
  String payload = "chat_id=" + String(CHAT_ID) + "&text=" + urlencode(message);

  const int maxRetries = 3;
  int attempt = 0;
  bool success = false;

  while (attempt < maxRetries && !success) {
    Serial.printf("üì§ Attempt %d to send Telegram message...\n", attempt + 1);
    if (!https.begin(client, url)) {
      Serial.println("‚ùå HTTPS begin() failed.");
      break;
    }

    https.addHeader("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8");
    int httpCode = https.POST(payload);

    if (httpCode > 0) {
      Serial.printf("‚úÖ Telegram response code: %d\n", httpCode);
      success = (httpCode == 200);
    } else {
      Serial.printf("‚ö†Ô∏è HTTP POST failed. Code: %d | Error: %s\n", httpCode, https.errorToString(httpCode).c_str());
    }

    https.end();
    attempt++;
    if (!success) delay(1500); // Wait before retry
  }

  if (!success) {
    Serial.println("‚ùå All attempts to send Telegram failed.");
  }

  return success;
}



String urlencode(String str) {
  String encoded = "";
  char c;
  char code0, code1;
  for (int i = 0; i < str.length(); i++) {
    c = str.charAt(i);
    if (isalnum(c)) {
      encoded += c;
    } else {
      code1 = (c & 0xf) + '0';
      if ((c & 0xf) > 9) code1 = (c & 0xf) - 10 + 'A';
      code0 = ((c >> 4) & 0xf) + '0';
      if (((c >> 4) & 0xf) > 9) code0 = ((c >> 4) & 0xf) - 10 + 'A';
      encoded += '%';
      encoded += code0;
      encoded += code1;
    }
  }
  return encoded;
}
