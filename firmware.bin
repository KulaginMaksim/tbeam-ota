#include <TinyGPSPlus.h>
#include <HardwareSerial.h>
#include <XPowersLib.h>
#include <WiFi.h>
#include <WiFiClientSecure.h>
#include <HTTPClient.h>
#include <time.h>
#include <algorithm>

#define MAX_SAFE_POINTS 20

// –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –∑–æ–Ω–∞
double safeZoneLats[MAX_SAFE_POINTS];
double safeZoneLngs[MAX_SAFE_POINTS];
int safeZoneIndex = 0;
bool safeZoneReady = false;
double safeZoneLatCenter = 0.0;
double safeZoneLngCenter = 0.0;

// WiFi / Telegram
const char* ssid = "MEO-7C6930";
const char* password = "0d2ad4596f";
const char* BOT_TOKEN = "7090059734:AAECfFez6-5pJVqOviJyZhXtmvfn9NMDfBE";
const char* CHAT_ID = "220442872";

unsigned long lastSendTime = 0;
const unsigned long sendInterval = 15000;

#define GPS_RX_PIN 34
#define GPS_TX_PIN 12
#define I2C_SDA_PIN 21
#define I2C_SCL_PIN 22
#define GPS_BAUD_RATE 9600

TinyGPSPlus gps;
HardwareSerial GPS_Serial(1);
XPowersAXP2101 power;

void fakeTime() {
  struct tm t;
  t.tm_year = 2025 - 1900;
  t.tm_mon = 5;
  t.tm_mday = 24;
  t.tm_hour = 3;
  t.tm_min = 0;
  t.tm_sec = 0;
  time_t fakeEpoch = mktime(&t);
  struct timeval now = { .tv_sec = fakeEpoch };
  settimeofday(&now, nullptr);
  Serial.println("‚ö†Ô∏è –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø–æ–¥—Å—Ç–∞–≤–Ω–æ–µ –≤—Ä–µ–º—è (–±–µ–∑ NTP)");
  Serial.print("üïí ");
  Serial.println(ctime(&fakeEpoch));
}

void setup() {
  Serial.begin(115200);
  while (!Serial);
  Serial.println("GPS T-Beam + Telegram");

  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("\nWiFi connected. IP: " + WiFi.localIP().toString());

  Wire.begin(I2C_SDA_PIN, I2C_SCL_PIN);
  if (!power.init()) {
    Serial.println("PMIC FAIL");
    while (1) delay(1000);
  }
  power.setProtectedChannel(XPOWERS_ALDO2);
  power.enableALDO2();

  GPS_Serial.begin(GPS_BAUD_RATE, SERIAL_8N1, GPS_RX_PIN, GPS_TX_PIN);
  fakeTime();
}

void loop() {
  while (GPS_Serial.available() > 0) {
    char c = GPS_Serial.read();
    Serial.write(c);
    if (gps.encode(c) && gps.location.isValid()) {
      if (millis() - lastSendTime > sendInterval) {
        displayAndSendInfo();
        lastSendTime = millis();
      }
    }
  }
  if (millis() > 5000 && gps.charsProcessed() < 10) {
    Serial.println("WARNING: No GPS data!");
    ESP.restart();
  }
}

void addSafePoint(double lat, double lng) {
  if (safeZoneIndex >= MAX_SAFE_POINTS) return;
  safeZoneLats[safeZoneIndex] = lat;
  safeZoneLngs[safeZoneIndex] = lng;
  safeZoneIndex++;

  if (safeZoneIndex == MAX_SAFE_POINTS) {
    std::sort(safeZoneLats, safeZoneLats + MAX_SAFE_POINTS);
    std::sort(safeZoneLngs, safeZoneLngs + MAX_SAFE_POINTS);
    safeZoneLatCenter = safeZoneLats[MAX_SAFE_POINTS / 2];
    safeZoneLngCenter = safeZoneLngs[MAX_SAFE_POINTS / 2];
    safeZoneReady = true;
    Serial.println("‚úÖ –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –∑–æ–Ω–∞ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞");
    Serial.printf("–¶–µ–Ω—Ç—Ä: %.6f, %.6f\n", safeZoneLatCenter, safeZoneLngCenter);
  }
}

bool maleraiusCheck(double currentLat, double currentLng) {
  if (!safeZoneReady) return false;
  double distFromCenter = distanceBetween(currentLat, currentLng, safeZoneLatCenter, safeZoneLngCenter);
  return distFromCenter > 50.0;
}

double distanceBetween(double lat1, double lon1, double lat2, double lon2) {
  const double R = 6371000;
  double dLat = radians(lat2 - lat1);
  double dLon = radians(lon2 - lon1);
  double a = sin(dLat / 2) * sin(dLat / 2) +
             cos(radians(lat1)) * cos(radians(lat2)) *
             sin(dLon / 2) * sin(dLon / 2);
  double c = 2 * atan2(sqrt(a), sqrt(1 - a));
  return R * c;
}

void displayAndSendInfo() {
  static double lastLat = 0, lastLng = 0;
  static unsigned long lastSent = 0;
  static bool wasMoving = false;
  static double moveBuffer[5] = {0};
  static int bufferIndex = 0;
  static bool gpsInitialized = false;

  if (!gps.location.isValid()) {
    Serial.println("INVALID | Lat: --- | Lng: ---");
    return;
  }

  double lat = gps.location.lat();
  double lng = gps.location.lng();

  if (!gpsInitialized) {
    lastLat = lat;
    lastLng = lng;
    gpsInitialized = true;
    Serial.println("‚è≥ –ü–µ—Ä–≤–∞—è –≤–∞–ª–∏–¥–Ω–∞—è —Ç–æ—á–∫–∞. –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç.");
    return;
  }

  if (!safeZoneReady) addSafePoint(lat, lng);

  double dist = distanceBetween(lastLat, lastLng, lat, lng);
  unsigned long now = millis();

  moveBuffer[bufferIndex] = dist;
  bufferIndex = (bufferIndex + 1) % 5;

  double tempBuffer[5];
  memcpy(tempBuffer, moveBuffer, sizeof(moveBuffer));
  std::sort(tempBuffer, tempBuffer + 5);
  double medianDist = tempBuffer[2];

  bool gpsGood = gps.hdop.value() / 100.0 <= 2.0 && gps.satellites.value() >= 6;
  bool allAboveThreshold = true;
  for (int i = 0; i < 5; i++) {
    if (moveBuffer[i] <= 35.0) {
      allAboveThreshold = false;
      break;
    }
  }

  bool distOk = dist > 30.0 && medianDist > 30.0 && maleraiusCheck(lat, lng);
  bool isMoving = gpsGood && distOk;

  if (isMoving == wasMoving) {
    if ((isMoving && (now - lastSent < 15000)) || (!isMoving && (now - lastSent < 3600000))) {
      Serial.println(isMoving ? "üèÉ –î–≤–∏–∂–µ–º—Å—è. –ü–æ–¥–æ–∂–¥—ë–º..." : "üßç –°—Ç–∞—Ü–∏–æ–Ω–∞—Ä–Ω–æ. –ü–æ–¥–æ–∂–¥—ë–º...");
      return;
    }
  }

  lastLat = lat;
  lastLng = lng;
  lastSent = now;
  wasMoving = isMoving;

  int sats = gps.satellites.value();
  double hdop = gps.hdop.value() / 100.0;
  double alt = gps.altitude.meters();
  float battVoltage = power.getBattVoltage();

  Serial.printf("VALID | Lat: %.6f | Lng: %.6f | Sats: %d | HDOP: %.1f | Alt: %.1fm | Dist: %.1fm | Median: %.1fm\n",
                lat, lng, sats, hdop, alt, dist, medianDist);

  String msg = isMoving
      ? "üèÉ –ú—ã –¥–≤–∏–∂–µ–º—Å—è!\nüìç GPS –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–∞–∂–¥—ã–µ 15 —Å–µ–∫—É–Ω–¥\n"
      : "üßç –°—Ç–∞—Ü–∏–æ–Ω–∞—Ä–Ω–æ.\nüìç GPS –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ä–∞–∑ –≤ —á–∞—Å\n";

  msg += "üåê Lat: " + String(lat, 6) + "\n";
  msg += "üåê Lng: " + String(lng, 6) + "\n";
  msg += "üì° Sats: " + String(sats) + "\n";
  msg += "üìè HDOP: " + String(hdop, 1) + "\n";
  msg += "üóª Alt: " + String(alt, 1) + " –º\n";
  msg += "üìè –°–º–µ—â–µ–Ω–∏–µ: " + String(dist, 1) + " –º\n";
  msg += "üìä –ú–µ–¥–∏–∞–Ω–Ω–æ–µ —Å–º–µ—â–µ–Ω–∏–µ: " + String(medianDist, 1) + " –º\n";
  msg += "üîã –ë–∞—Ç–∞—Ä–µ—è: " + String(battVoltage / 1000.0, 2) + " –í\n";
  msg += "üó∫Ô∏è https://maps.google.com/?q=" + String(lat, 6) + "," + String(lng, 6) + "\n";

  sendToTelegram(msg);
}

bool sendToTelegram(const String& message) {
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("üö´ WiFi not connected. Cannot send Telegram.");
    return false;
  }

  WiFiClientSecure client;
  client.setInsecure();
  HTTPClient https;

  String url = "https://api.telegram.org/bot" + String(BOT_TOKEN) + "/sendMessage";
  String payload = "chat_id=" + String(CHAT_ID) + "&text=" + urlencode(message);

  const int maxRetries = 3;
  int attempt = 0;
  bool success = false;

  while (attempt < maxRetries && !success) {
    if (!https.begin(client, url)) {
      Serial.println("‚ùå HTTPS begin() failed.");
      break;
    }

    https.addHeader("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8");
    int httpCode = https.POST(payload);
    success = (httpCode == 200);
    https.end();
    attempt++;
    if (!success) delay(1500);
  }

  return success;
}

String urlencode(String str) {
  String encoded = "";
  char c;
  char code0, code1;
  for (int i = 0; i < str.length(); i++) {
    c = str.charAt(i);
    if (isalnum(c)) {
      encoded += c;
    } else {
      code1 = (c & 0xf) + '0';
      if ((c & 0xf) > 9) code1 = (c & 0xf) - 10 + 'A';
      code0 = ((c >> 4) & 0xf) + '0';
      if (((c >> 4) & 0xf) > 9) code0 = ((c >> 4) & 0xf) - 10 + 'A';
      encoded += '%';
      encoded += code0;
      encoded += code1;
    }
  }
  return encoded;
}
